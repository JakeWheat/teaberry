
understand the apis properly
where to do stmt, [stmt] and expr

multiple _
using _

do desugaring for statements
do interp for statements
write some simple demo scripts

recursive functions
fun
mutually recursive functions
  do a let* in the interpreter?

implement not, and, or, sugar for if
print function

language demo prerequisites:

  algebraic data typesx
  pattern binding
  parametric polymorphism





how to make it more like an actual language?

parse a script: which is a series of top level stuff
ability to parse and run blocks/lists of statements

check the thing with blocks and multiple expressions

command line front end to run a simple script

add print command
  -> put the interpreter in a monad stack


do fun


implement recursive functions
do rec also, make fun recursive
try to do mutually recursive functions


do variables


implement not, and, or, sugar for if

implement a basic library of functions


think about the minimum needed to reproduce the pyret lang
 implemention in this language:
  algebraic data types
  proper pattern binding (at least for constructors)
  list type
  can use the haskell s exp parser as a ffi function

think about if this is implemented in haskell, is it lazy in places?
how to make sure it's completely strict

what about representing closure values using a haskell function
  instead of an exprc, so the syntax doesn't leak into the values data
  type

see if can make a repl with this

add some contracts, especially the simple type ones

add algebraic data types, case
recursive data types
add fuller case + stuff
will this cover tuples, records?

add parametric polymorphism

try to do pattern binding and build a combined cases + ask


add types



small todos:
figure out all the required whitespace or no whitespace
multiline comments and non multiline comments
string escaping
multiline and non mutliline strings
identifiers business
reserved keywords
review a full set of binary operators
tuple stuff
currying stuff
lambda shorthand
chain expressions
template
check handling of precedence and requiring of ()
decide on ast annotations for source positions for error messages
  -> read about the racket stuff

do a pretty printer for syntax?
maybe do parser and pretty printer for the intepreter syntax?

work on error messages


what is a full set of types?
number types
bool
string
binary
struct
tuple
algebraic data type (can this implement struct and tuple?)
array?
how do extensible records work?
dates and times
support annotations
support controls
add type assertion expression operator
