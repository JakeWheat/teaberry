
quick pass on the laziness: make all the main data types strict
add strictness stuff to the interpreter

milestones:

values and variables branch:
implement variables
if adding a store - does this require a garbage collector which can't
  cheat and magically reuse the ghc one?
switch to a monad stack using reader for env
algebraic data types
  -> simple variants, use the dynamic . only?
  then add simple case statements
  then add the case sugar for:
       nested ctor
       literals
       guards
  desugar if to case?
  implement some more data types - maybe do a pyret review at this point
for algebraic data types and parametric polymorphism, try to do some
  design on what kind of datatype mismatches will be caught at runtime
  and when - this will determine what needs to sit with the values and
  be passed around as context
try for loops and the direct fold example
parametric polymorphism
extended lvalues
implement the simple language demo

try to write a is_free function
and a get all free variables function
and a safe variable rename function

syntax review branch: to get a substantial amount of pyret syntax supported
check all the optional blocks
check the implicit blocks
curly brace lambda shorthand
curried application
chaining application
call function with parametric signature - just ignore for now
fuller set of binary operators
tuples
dot expressions
extend expression - needs records
for expressions
template expressions
check that _ works as a wild card, can't look it up, doesn't add to
  the env
mutable fields?
construction expressions
expression forms of bindings: make sure these are all covered
make notes on what is and isn't supported
eventually go through papl to see what also works here

files/letrec branch:
do the variable based letrec for now
check and where
lots more tests for desugaring files and blocks
get to running whole single files from command line
see if can do a repl and an embedded api sketch
--dump-parse
--dump-desugar + pretty printed versions
extend to multiple files, import, export


rough next steps:

control flow (exceptions at least, plus maybe early return,
continue/break)

types

standard lib: start with the review of pyret's and python's

lots more testing
  benchmarking to monitor performance improvements and regressions
  try to find some good benchmark programs to run
  anomaly testing
  get code coverage working
  
lots of example scripts

documentation

contracts, annotations

extensible records

extensibility ffi

create a client driver, embedded and ffi story for haskell, c and
python

distributed api, multiprocess/concurrency sketch (base on erlang or e
or cloud haskell?)

want a where like in haskell:
  maybe rename the pyret where: to examples:

goto?

error messages linked to source positions

gradual typing design

syntax and parsing review:
  whitespace handling
  multiline and non multiline strings, comments
  string escaping
  a full set of binary operators. will this be fixed or extensible?


ci
anomaly testing
start thinking about benchmarking:
  what to benchmark
    compilation times
    building this product
    running the tests
    other infrastructure activities
    running scripts
  how to do it
documentation, for the implementation and for users

