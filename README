
A learning project to implement a dialect of Pyret.

Goal is to implement a dialect of Pyret in Haskell, with a high level
interpreter, to learn how to implement functional programming + a
basic type system. The original goal was to implement a language
roughly along the lines of 'Python, but with proper functional
programming and types', and Pyret is very close to this, so I'm mostly
copying Pyret for the time being.

Not ready for human consumption yet.

Demonstration of most supported features:
https://github.com/JakeWheat/teaberry/tree/master/examples/tests/fulltests/tour.tea

See the examples and built in modules directories for more:

https://github.com/JakeWheat/teaberry/tree/master/examples/tests/fulltests
https://github.com/JakeWheat/teaberry/tree/master/built-in-modules

This is how I compile and run the code from source:

cabal run RunTests --disable-optimization -- --hide-successes --ansi-tricks=false

and how I use the command line interface:

cabal run -v0 teaberry --disable-optimization -- -g examples/tests/fulltests/tour.tea

(disabling the optimsation doesn't seem to make anything slower at
this stage, and makes ghc compile it much faster)

# About Pyret

Pyret is a really nice functional language with an optional type
checker primarily aimed at teaching programming at the moment.

Homepage:
https://www.pyret.org/
Manual:
https://www.pyret.org/docs/latest/index.html
PAPL, a tutorial for Pyret, programming, and implementing programming languages:
https://papl.cs.brown.edu/2019/index.html

The other big source of knowledge was PLAI, a book about implementing
programming languages (there is some overlap with the second half of
PAPL):
https://www.plai.org/

I found PLAI and PAPL to be much easier for learning how to implement
programming languages than the other usual suspects.

This language will diverge from Pyret.

# sketch of early approximate target

mostly pyret syntax to start with
strict/eager
basic functional programming: functions as values + closures
algebraic data types + pattern binding
typed only, with inference (will remain untyped for a while yet)
parametric polymorphism
type classes
non whitespace significant (except maybe copying some of pyret, but
  not indentation significant)
no purity tracking in the type system
  (to be reviewed)
exceptions (to be reviewed)
garbage collection
resource management
control flow: break, continue, goto ?
no implicit casting
no pragmas, javadoc in comment syntax
good error messages
extensible records

# sketch of possible roadmap

This list mostly uses Pyret terminology for the things that are also in Pyret.

## Completed (no rigorous testing or completeness checks yet)

quick hack command line interface

lambda values, app
closures
letrec

tuples
records
vars
lists
algebraic data types
recursive data types (cheating slightly without types)
pattern binding in let
cases
references (mutable fields)
construct expressions

check, where

shadow (syntax only, shadowing not detected)

usable subset of import, provide, include
  doesn't check for import cycles yet, will probably hang if you do
  this
    

## planned

full import, provide, include support
  provide: type x end
  provide: data x end
  provide:
    data MyPosn hiding (pos2d, pos3d)
  end

  the non-file non-built in import sources? not sure if will do any of them

  provide:
    * hiding (concat-helper)
  end
  provide from SD: * end
  provide:
    module SD
  end

  provide *
  provide-types *
    not sure if these are deprecated

contracts and annotations

critical whitespace issues
  1. no space between expr and () in app
  2. no multiple statements without newline

extended pattern binding

types
  needs a todo list
  algebraic data types
    field access in a case
  recursive functions
  recursive data types
  parametric polymorphism
  type classes
  extensible records
  ...

type inference

a better command line interface

a bit more of an ffi

## smaller planned items

check additional features:
  is-not
  is%
  is-not%
  satisfies
  violates
  raises-other-than
  raises-violates

shadow (actually does something)

lambda shorthand
for loops
curried application
block shorthands
non blocky blocks

pattern binding in lambda, functions arguments
record binding

... and variations (like with a message)

doc strings

type and new type

improved set of builtin/basic types

program output fixed to match pyret

fixity handling

source location information available to code
  (__FILE__, etc.)

spy statement

